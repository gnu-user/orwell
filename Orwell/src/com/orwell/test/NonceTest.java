package com.orwell.test;

import static org.junit.Assert.*;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.spongycastle.crypto.digests.SHA256Digest;
import org.spongycastle.crypto.engines.ISAACEngine;
import org.spongycastle.crypto.params.Nonce;
import org.spongycastle.util.encoders.Hex;

import org.junit.Before;
import org.junit.Test;
import org.junit.contrib.assumes.Assumes;
import org.junit.contrib.assumes.Corollaries;
import org.junit.runner.RunWith;

import com.orwell.csprng.ISAACRandomGenerator;
import com.orwell.csprng.SDFGenerator;
import com.orwell.csprng.SDFParameters;

@RunWith(Corollaries.class)
public class NonceTest
{
	private SDFParameters aliceParamSDF;
	private SDFParameters bobParamSDF;
	private SDFGenerator aliceGeneratorSDF;
	private SDFGenerator bobGeneratorSDF;
	
	private byte[] aliceSeed;
	private byte[] bobSeed;
	
	private ISAACRandomGenerator aliceCSPRNG;
	private ISAACRandomGenerator bobCSPRNG;
	
	private Nonce aliceNonce;
	private Nonce bobNonce;
	
	
	private byte[] expLastNonce;

	@Before
	public void setUp() throws Exception
	{
		/*
		 *  Inititialize the seed derivative function parameters for alice
		 *  and bob with the default  S1 & S2 parameters
		 */
		aliceParamSDF = new SDFParameters("initiator", "recipient");
		bobParamSDF = new SDFParameters("initiator", "recipient");
		
		// Generate the seeds using SHA256 digest
		aliceGeneratorSDF = new SDFGenerator(new SHA256Digest());
		bobGeneratorSDF = new SDFGenerator(new SHA256Digest());
		
		/* Initialize alice and bob's seed generators */
		aliceGeneratorSDF.init(aliceParamSDF);
		bobGeneratorSDF.init(bobParamSDF);
		
		/* Initialize seeds as size of digest used */
		aliceSeed = new byte[aliceGeneratorSDF.getDigest().getDigestSize()];
		bobSeed = new byte[bobGeneratorSDF.getDigest().getDigestSize()];
		
		
		/* Instantiate the CSPRNG */
		aliceCSPRNG = new ISAACRandomGenerator(new ISAACEngine());
		bobCSPRNG = new ISAACRandomGenerator(new ISAACEngine());
		
		/* Instantiate the nonces */
		aliceNonce = new Nonce(aliceCSPRNG);
		bobNonce = new Nonce(bobCSPRNG);
	}
	
	
	/**
	 * Basic test which verifies that alice and bob are able to generate
	 * the same seeds given that they have the same S1 & S2 parameters
	 * for the SDF 
	 */
	@Test
	public void sameSeeds()
	{
		/* Alice and bob generate seeds */
		aliceGeneratorSDF.generateBytes(aliceSeed, 0, 0);
		bobGeneratorSDF.generateBytes(bobSeed, 0, 0);
		
		System.out.println("\nAlice seed LENGTH: " + aliceSeed.length);
		System.out.println("Alice SEED: " + new String(Hex.encode(aliceSeed)));
		System.out.println("Bob seed LENGTH: " + bobSeed.length);
		System.out.println("Bob SEED: " + new String(Hex.encode(bobSeed)));
		
		/* Verify alice and bob have same seeds */
		assertTrue(Arrays.equals(aliceSeed, bobSeed));
	}

	
	/**
	 * Test that alice and bob are able to generate the same sequence of nonces given
	 * that they both have the same seeds. This verifies that the CSPRNG and thus nonces
	 * generated are deterministic and can be generated by both individuals if they
	 * have the same initial seed.
	 */
	@Test
	@Assumes("sameSeeds")
	public void sameNonceSequence()
	{
		/* Initialize the nonces with the seeds */
		aliceNonce.init(aliceSeed, 32);
		bobNonce.init(bobSeed, 32);
		
		/* Generate a sequence of 1000 nonces and verify that both alice and bob
		 * have the same exact sequence of nonces
		 */		
		ArrayList<byte[]> aliceNonceSequence = new ArrayList<byte[]>();
		ArrayList<byte[]> bobNonceSequence = new ArrayList<byte[]>();
		
		for (int i = 0; i < 1000; ++i)
		{
			aliceNonceSequence.add(aliceNonce.nextNonce());
			
			bobNonce.nextNonce();
			bobNonceSequence.add(bobNonce.getNonce());
			
		}
		
		for (int i = 0; i < 10; ++i)
		{	
			System.out.println("Alice NONCE: \t" + new String(Hex.encode(aliceNonceSequence.get(i))));
			System.out.println("Bob NONCE: \t" + new String(Hex.encode(bobNonceSequence.get(i))));
		}
		
		for (int i = 0; i < 1000; ++i)
		{	
			assertTrue(Arrays.equals(aliceNonceSequence.get(i), bobNonceSequence.get(i)));
		}	
	}
	
	
	/**
	 * Test that the nonce generator can be restored to a previous state and can correctly
	 * generated the sequence avoiding the risk of repeating IVs.
	 */
	 @Test
    public void restoreNonceState()
    {
        /* Initialize the nonce with seeds */
        aliceNonce.init(aliceSeed, 32);
        ISAACRandomGenerator aliceCSPRNG2 = new ISAACRandomGenerator(new ISAACEngine());
        Nonce restoredNonce;
        
        /*
         * Generate a sequence of 1000 nonces and verify that the restored
         * Nonce is restored correctly and is able to generate the remaining
         * 500 nonces correctly from the restored state.
         */
        ArrayList<byte[]> aliceNonceSequence = new ArrayList<byte[]>();
        ArrayList<byte[]> restoredNonceSequence = new ArrayList<byte[]>();

        for (int i = 0; i < 500; ++i)
        {
            aliceNonceSequence.add(aliceNonce.nextNonce());
        }

        /* Initialize the restored nonce which is set to aliceNonce's 500th cycle */
        restoredNonce = new Nonce(aliceCSPRNG2, aliceNonce.getCycle());
        restoredNonce.init(aliceSeed, 32);
        
        /* Generate the remaining 500 nonces */
        for (int i = 0; i < 500; ++i)
        {
            aliceNonceSequence.add(aliceNonce.nextNonce());
            restoredNonceSequence.add(restoredNonce.nextNonce());
        }
        
        for (int i = 0; i < 10; ++i)
        {
            System.out.println("ORIGINAL NONCE: \t"
                    + new String(Hex.encode(aliceNonceSequence.get(500 + i))));
            System.out.println("RESTORED NONCE: \t" + new String(Hex.encode(restoredNonceSequence.get(i))));
        }

        /* Verify that the remaining 500 nonces match, the restored nonce generator is correct */
        for (int i = 0; i < 500; ++i)
        {
            assertTrue(Arrays.equals(aliceNonceSequence.get(500 + i), restoredNonceSequence.get(i)));
        }
    }

}
